# creat()

> [!note]  
> 본 문서는 숭실대학교 컴퓨터학부 홍지만 교수님의 2024년 1학기 리눅스시스템프로그래밍 수업을 듣고 정리한 내용입니다. 모든 내용은 개인적으로 정리한 것으로, 틀린 부분이 있을 수 있습니다.

<br>

```c
#include <sys/stat.h> // mode 인자에 들어갈 flag 정의 (open()의 mode 인자와 동일)
#include <sys/types.h> // 타입 mode_t의 정의
#include <fcntl.h> // creat()

int creat(const char *pathname, mode_t mode);
```

- `pathname`: 생성할 파일의 상대 경로 또는 절대 경로
- `mode`: 생성할 파일의 접근 권한으로 파일의 읽기, 쓰기, 실행 모드 지정 가능하며, [open()](https://github.com/junghyun21/ssu-os-lab/tree/main/university_courses/2024-linux-system-programming/02-file-io/open)의 mode 인자와 동일
- reture 값: 성공 시 쓰기 전용으로 생성 및 오픈된 파일 디스크립터 반환, 실패 시 -1 반환 및 errno 설정

<br>

[creat()](./creat1.c)는 **파일을 생성할 때 사용하는 시스템콜 함수**이며, `open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode)`와 동일한 기능을 갖는다. 즉, `creat()`는 파일을 쓰기 전용으로만 오픈하고, 이미 동일한 이름의 파일이 존재한다면 기존의 파일 내용을 삭제한다. 이 때, 기존 파일의 접근 권한 모드는 변경되지 않는다. 파일 생성을 성공하기 위해서는 아래의 두 가지 조건을 만족해야 한다.

1. **파일을 생성하고자 하는 경로에 해당하는 디렉토리에 대해 쓰기 권한을 가지고 있어야 한다.**  
    → 디렉토리에 대한 쓰기 권한이 있다는 것은 해당 디렉토리 내 파일의 생성/삭제/이름 변경이 가능함을 의미
2. **동일한 이름의 파일이 존재한다면, 그 파일에 대한 쓰기 권한을 가지고 있어야 한다.**  
    → 동일한 이름의 파일이 존재할 때에는 새롭게 파일이 생성되는 것이 아닌, 기존의 파일 내용이 삭제  
    → 즉, 파일의 접근 권한 모드는 기존의 파일과 동일  
    → creat() 함수는 항상 파일을 쓰기 전용으로만 오픈  
    → 기존의 파일에 대한 쓰기 권한이 없다면, 동일한 이름의 파일 생성 불가능

<br><br>

### open() vs creat()

최근에는 `open()`에서 `O_CREAT` 플래그를 통해 `creat()`를 대신하는 추세이다. 이는 `creat()`의 번거로움 때문인데, `creat()`는 생성한 파일을 **쓰기 전용으로 오픈**하기 때문에, 오픈한 파일에 쓰여진 데이터를 읽기 위해서는 일단 그 파일을 닫고 다시 읽기/쓰기(O_RDWR) 혼용 접근 권한으로 다시 오픈해야만 한다.

```c
fd = creat(fname, 0666); // 파일 생성 및 쓰기 전용으로 오픈
close(fd); // 파일 닫기
fd = open(fname, O_RDWR); // 읽기쓰기 혼용 접근 권한으로 재오픈
```

[[source] creat()로 생성한 파일을 open()을 통해 오픈](./creat2.c)