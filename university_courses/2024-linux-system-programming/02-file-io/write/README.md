# write()

> [!note]  
> 본 문서는 숭실대학교 컴퓨터학부 홍지만 교수님의 2024년 1학기 리눅스시스템프로그래밍 수업을 듣고 정리한 내용입니다. 모든 내용은 개인적으로 정리한 것으로, 틀린 부분이 있을 수 있습니다.

<br>

```c
#include <unistd.h>

ssize_t write(int filedes, const void *buf, size_t nbytes);
```

- `filedes`: 데이터를 쓸 파일을 가리키는 파일 디스크립터
- `buf`: 쓰려는 데이터를 포함하는 버퍼의 시작 주소
- `nbytes`: 쓸 바이트 수
- reture 값: 성공 시 읽어온 바이트 수 또는 파일의 끝에 도달한 경우에는 0, 실패 시 -1 반환 및 errno 설정

<br>

[write()](./write1.c)는 **오픈한 파일에 데이터를 쓸 때 사용되는 시스템콜 함수**로, 지정된 메모리(buf)로부터 쓰기 전용 또는 읽기 쓰기 혼용 접근 권한으로 오픈된 파일(filedes)로 정해진 바이트(nbytes)만큼의 데이터를 기록한다. 이 때 반드시 **실제로 기록한 바이트 수는 정해진 바이트 수와 일치**해야 하며, 그렇지 않은 경우에는 어디선가 에러가 발생한 것으로 간주한다. 또한 `write()`는 파일의 실제 데이터가 저장된 블록 상태를 직접 다루는 것이 아닌, i-node를 통해 데이터에 접근한다. 따라서 데이터의 일관성을 위해 `write()` 호출 시, 커널은 호출이 수행되는 동안 i-node에 락(lock)을 걸고 해당 파일에 접근하려는 다른 모든 연산을 블록(block)시킨다. 즉, `write()`가 수행되는 동안은 해당 파일의 i-node에 대한 어떠한 접근도 허용하지 않는다.

<br><br>

### 예제

- [[source] write()를 통해 구현한 cp 명령어](./write2.c)
- [[source] employeefile.txt 파일에 직원 정보를 구조체 단위로 기록](./write3.c)