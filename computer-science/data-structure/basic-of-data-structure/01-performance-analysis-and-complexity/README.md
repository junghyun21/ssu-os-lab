# 1-1 알고리즘의 성능 분석과 정확도
알고리즘의 성능은 시간 복잡도와 공간 복잡도로 측정할 수 있다. 시간 복잡도는 알고리즘이나 프로그램이 얼마나 빠르게 실행되는가를 나타내는 척도이고, 공간 복잡도는 얼마나 많은 메모리는 사용하는지를 나타내는 척도이다. <br><br>

### 시간 복잡도

알고리즘을 구성하는 명령어들의 실행 횟수와 각 명령어의 실행 시간을 곱한 합계이다. 그러나 프로그래밍 언어나 하드웨어에 따라 명령어의 실행시간이 달라지므로 일반적으로 시간복잡도는 **명령어의 실행 횟수**만 고려한다.  
시간 복잡도를 표현하기 위해 입력 개수(n)의 값으로 함수로 나타낸 것을 **시간 복잡도 함수**라고 하며, 이를 입력 개수 n에 따라 프로그램 또는 코드의 실행 시간이 얼마나 영향을 받고 변화하는지를 알 수 있다.

일반적인 시간 복잡도의 비교는 다음과 같다.  
O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

- 재귀 함수를 통해 배열의 값들의 합: `O(n)`
    ```C
    float rSum(float a[], int n)
    {
        if(n <= 0)
            return (0.0);
        else
            return (rSum(a, n-1) + a[n]);
    }
    ```

- 배열에서 중복된 값을 찾아 해당 값을 0으로 설정: `O(n^2)`
    ```c
    void func(int *a, n)
    {
        int i = 0, j = 0;
        for(i = 0; i < n - 1; i++)
            for(j = i + 1; j < n; ++j)
                if(a[i] == a[j]) a[j] = 0;
    }
    ```

- 문자 배열의 순열 생성 및 출력: `O(n(n!))` (일반적으로 O(n!)으로 표기)
    ```c
    #include <stdio.h>
    #define SWAP(x, y, t) (t = x, x = y, y = t)

    int main(int argc, char *argv[])
    {
        char txt[4] = {'a', 'b', 'c'};
        perm(txt, 0, 2);
        return 0;
    }

    void perm(char *list, int i, int n)
    {
        int j, temp;

        if(i == n){
            for(j = 0; j <= n; j++)
                printf("%c", list[j]);
            printf("    ");
        }
        else{
            for(j = i; j <= n; j++){
                SWAP(list[i], list[j], temp);
                perm(list, i+1, n);
                SWAP(list[i], list[j], temp);
            }
        }
    }
    ```

<br>

### 공간 복잡도

알고리즘이나 프로그램 실행 시, 얼마나 많은 메모리 공간을 사용하는지를 나타내는 척도이다. 이는 고정적으로 요구되는 공간과 가변적으로 요구되는 공간으로 나눌 수 있다.

- 고정적 공간
    - 프로그램 코드가 저장되는 공간
    - 단순 변수를 위한 공간
    - 고정된 크기의 구조체 변수나 상수들을 위해 필요한 공간

- 가변적 공간
    - 특정 입력에 따라 필요한 크기가 달라지는 공간

<br>

### 점근적 알고리즘 분석과 점근 표기법

점근적 분석(점근적 알고리즘 분석, Asymptotic Algorithm Analysis)은 입력 크기(n)가 커질 수록 알고리즘 또는 프로그램의 효율성이 어떻게 변화하는지 측정한다. 즉, 이를 통해 **입력 크기의 증가에 따라 알고리즘 실행시간이 어떻게 증가되는지**를 표현할 수 있다.  
실제로 입력 크기가 작은 경우에는 알고리즘의 효율성이 그렇게 중요하지 않다. 심지어는 비효율적인 알고리즘이 더 좋은 결과를 보이기도 한다. 그러나 **입력 크기가 커지는 경우에는 알고리즘의 효율성이 중요해지기 때문에 우리는 입력 크기가 충분히 큰 경우에 대한 분석이 필요하다.** 따라서 우리는 점근적 분석을 통해 알고리즘의 성능을 분석 해야 한다.

- O (Big-O)
    - 함수의 상한을 나타내는 점근 표기법
    - f(n) = O(g(n))
        - `f(n) ≤ c⋅g(n) for all n ≥ n1` 을 만족하는 양의 상수 c와 n1이 존재
        - g(n)은 f(n)의 점근적 상한
        - f(n)은 최대 g(n)의 명령어 실행 횟수를 가질 수 있음
        - f(n)은 g(n)보다 명령어 실행 횟수의 값이 느리게 증가함
        - f(n)의 알고리즘 성능이 최악이더라도 g(n)의 이상임

- Ω (Omega)
    - 함수의 하한을 나타내는 점근 표기법
    - f(n) = Ω(g(n))
        - `f(n) ≥ c⋅g(n) for all n ≥ n1` 을 만족하는 양의 상수 c와 n1이 존재
        - g(n)은 f(n)의 점근적 하한
        - f(n)은 최소한 g(n)의 명령어 실행 횟수를 가질 수 있음
        - f(n)은 적어도 g(n)보다 명령어 실행 횟수의 값이 빠르게 증가함
        - f(n)의 알고리즘 성능이 아무리 좋더라도 g(n)의 이하임

- Θ (Theata)
    - 함수의 상한 및 하한을 나타내는 점근 표기법
    - f(n) = Θ(g(n))
        - `c1⋅g(n) ≤ f(n) ≤ c2⋅g(n) for all n ≥ n1` 을 만족하는 양의 상수 c1, c2와 n1이 존재
        - g(n)은 f(n)의 점근적 상한 및 하한
        - f(n)은 g(n)의 명령어 실행 횟수의 상한과 하한에서 어떤 고정된 비율에 따라 증가함  
        - 즉, f(n)은 g(n)과 동일한 비율로 명령어 실행 횟수가 증가함
        - f(n)의 알고리즘 성능은 최적의 경우이든 최악의 경우이든 모두 g(n)에 비례하는 성능을 나타냄  
<br>

> O, Ω, Θ의 관계

```
f(n) = O(g(n)) ∧ f(n) = Ω(g(n)) ⇒ f(n) = Θ(g(n))
```

- `O(g(n))`: f(n)은 n이 증가할 때, g(n)보다 빠르게 증가하는 함수
- `Θ(g(n))`: f(n)은 n이 증가할 때, g(n)과 같은 비율로 증가하는 함수
- `Ω(g(n))`: f(n)은 n이 증가할 때, g(n)보다 느리게 증가하는 함수

<br>

### 프로그램 실행 시간 측정

프로그램의 실행 시간을 측정하는 방법에는 데이터 타입 `clock_t`와 `time_t`을 활용한 방법이 있다. 두 방법에서 사용되는 자료형, 함수, 상수는 헤더파일 `<time.h>`에 정의되어 있다.

[source](https://github.com/junghyun21/ssu-os-lab/new/main/computer-science/data-structure/basic-of-data-structure/01-performance-analysis-and-complexity/running_time.c)

- clock_t
    - `clock()` 함수는 CPU의 clock 수를 통해 시간 측정
    - `clcok()` 함수는 1초에 1000clock으로 정의되어 있으므로, 1 clock은 1ms임
    - 예를 들어 측정 중간에 `sleep()`이 사용된다면, 정확한 시간 측정이 어려울 수 있음
    - 기본 ms 단위로 측정
    - 초 단위의 측정을 원한다면 `CLOCL_PER_SEC`으로 나누어 주면 됨

- time_t
    - `time()` 함수는 현재 캘린더 시간을 통해 시간 측정
    - 초 단위 측정만 가능
